# 객체지향언어

## 객체지향언어의 역사

- '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다'

## 객체지향언어

- 기존의 프로그래밍언어와 다른 전혀 새로운 것이 아니라, 기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 보다 발전된 형태의 것
- 규칙들을 이용해서 코드 간에 서로 관계를 맺어 줌 으로써 보다 유기적으로 프로그램을 구성하는 것이 가능해졌다
- 절차적 언어에 익숙한 프로그래밍 습관을 객체지향적으로 바꾸도록 노력하기!
- 객체지향언어의 주요특징

```java
1. 코드의 재사용성이 높다
새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다
2. 코드의 관리가 용이하다
코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다
3. 신뢰성이 높은 프로그래밍을 가능하게 한다
제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다
```

- 가장 큰 장점은 '코드의 재사용성이 높고 유지보수가 용이하다'는 것이다
  - 프로그램의 개발과 유지보수에 드는 시간과 비용을 획기적으로 개선
- 너무 객체지향개념에 얽매여서 고민하기 보다는 일단 프로그램을 기능적으로 완성한 다음 어떻게 하면 보다 객체지향적으로 코들르 개선할 수 있을 지를 고민하여 점차 개선해나가는 것이 좋다

# 클래스와 객체

## 클래스와 객체의 정의와 용도

**클래스의 정의** 클래스란 객체를 정의해놓은 것이다 <br>
**클래스의 용도** 클래스는 객체를 생성하는데 사용된다

- 클래스는 객체를 생성하는데 사용되며, 객체는 클래스에 정의된 대로 생성된다

```java
객체의 정의 : 실제로 존재하는 것, 사물 또는 개념
객체의 용도 : 객체가 가지고 있는 기능과 속성에 따라 다름

유형의 객체 : 책상, 의자, 자동차, TV와 같은 사물
무형의 객체 : 수학공식, 프로그램 에러와 같은 논리나 개념
```

- 객체지향이론에서는 사물과 같은 유형적인 것 뿐만 아니라, 개념이나 논리와 같은 무형적인 것들도 객체로 간주한다
  - 프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다
- 클래스와 객체의 관계를 우리가 살고있는 실생활에서 예를 들면, 제품 설계도와 제품과의 관계라고 할 수 있다
  - ex) TV설계도(클래스)는 TV라는 제품(객체)를 정의한 것 이며, TV(객체)를 만드는데 사용된다
- 클래스는 단지 객체를 생성하는데 사용될 뿐, 객체 그 자체는 아니다
  - 우리가 원하는 기능의 객체를 사용하기 위해서는 먼저 클래스로부터 객체를 생성하는 과정이 선행되어야한다
    - 우리가 TV를 보기 위해서는 TV(객체)가 필요한 것이지 TV설계도(클래스)가 필요한 것은 아니며, TV설계도(클래스)는 단지 TV라는 제품(객체)를 만드는데만 사용될 뿐이다
      - TV설계도를 통해 TV가 만들어진 후에야 사용할 수 있다
        - 프로그래밍에서는 먼저 클래스를 작성한 다음, 클래스로부터 객체를 생성하여 사용한다
          - 객체를 사용한다는 것은 객체가 가지고 있는 속성과 기능을 사용한다는 뜻이다
- 클래스를 정의하고, 클래스를 통해 객체를 생성하는 이유
  - 클래스를 잘 만들어놓으면, 매번 객체를 생성할 때 마다 어떻게 객체를 만들어야 할 지 고민 X
    - 그냥 클래스로부터 객체를 생성해서 사용하기만 하면되는 것이다
- JDK에서는 프로그래밍을 위해 많은 수의 융용한 클래스(Java API)를 기본적으로 제공하고 있다

## 객체와 인스턴스

- 클래스로부터 객체를 만드는과정을 클래스의 인스턴스화(instantiate)라고 한다
- 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(instance)라고 한다
  - ex) TV클래스로부터 만들어진 객체를 TV클래스의 인스턴스라고 한다
    - 결국 인스턴스는 객체와 같은 의미?
      - 객체는모든 인스턴스를 대표하느 포괄적인 의미를 갖고있으며, 인스턴스는 어떤 클래스로부터 만들어진 것인 지를 강조하는 보다 구체적의의미를 갖고있다

## 객체의 구성요소 - 속성과 기능

- 객체는 속성과 기능, 두종류의 구성요소로 이루어져 있으며, 일반적으로 객체는 다수의 속성과 다수의 기능을 갖는다
  - 즉 ,객체는 속성과 기능의 집합이라고 할 수 있다
  - 객체가 가지고 있는 속성과 기능을 그 객체의 멤버(구성원, member)라 한다
- 클래스란 객체를 정의한 것이므로 클래스에는 객체의 모든 속성과 기능이 정의되어 있다
  - 클래스로부터 객체를 생성하면, 클래스에 정의된 속성과 기능을 가진 객체가 만들어지는 것이다
- 속성과 기능은 같은 뜻의 여러가지 용어가 있다
  **속성(property)** 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)
  **기능(function)** 메서드(method), 함수(function), 행위(behavior)
- ex) TV의 속성과 기능
  - 속성 : 크기, 길이, 높이, 색상, 볼륨, 채널 등
  - 기능 : 켜기, 끄기, 볼륨 높이기, 볼륨 낮추기, 채널 변경하기 등
    - TV클래스 만들어보기

```java
class TV {
    String colot; // 색깔
    boolean power; // 전원상태, on과 off 두 가지 값을 가질 수 있으므로 boolean형으로 선언
    int channer; // 채널

    void power() { power = !power; } // poser의 값이 true면false로, false면 true로 변경하는 일을 한다. poser의 값에 관계없이 항상 반대의 값으로 변경해주면 되므로 굳이 if를 사용할 필요가 없다
    void channelUp() { channel++; }
    void channelDown() { channel--; }
}
```

-> 멤버변수와 메서드를 선언하느데 있어서 순서는 관계없지만, 일반적으로 메서드보다는 멤버변수를 먼저 선언하고 멤버변수는 멤버변수끼리 메서드는 메서드끼리 모아놓는 것이 일반적이다

```java
if (power) // if (power == true)
    power = false;
else
    power = true;
```

## 인스턴스의 생성과 사용

- 클래스로부터 인스턴스를 생성하는 방법

```java
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주솔르 참조변수에 저장

Tv t; // Tv클래스 타입의 참조변수 t를 선언
t = new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
```

```java
public class TvTest {
    public static void main(String[] args) {
        Tv t; // Tv인스턴스를 참조하기 위한 변수 t를 선언
        t = new Tv(); // Tv인스턴스를 생성한다
        t.channel = 7; // Tv인스턴스의 멤버변수 channel의 값을 7로 한다
        t.channelDown(); // Tv인스턴스의 메서드 channelDown()을 호출한다
        System.out.println("현재 채널은 " + t.channel + " 입니다. ");
    }
}

class  Tv {
    // Tv의 멤버변수
    String color; // 색상
    boolean power; // 전원상태(on/off)
    int channel; // 채널

    void power() {power = !power;} // TV를 켜거나 끄는 기능을 하는 메서드
    void channelUp() { ++channel; } // TV의 채널을 높이는 기능을 한느 메서드
    void channelDown() {--channel; } // TV의 채널을 낮추는 기능을 하는 메서드
}
```

- Tv클래스로부터 인스턴스를 생성하고 인스턴스의 속성(channel)과 메서드(channelDown())을 사용하는 방법을 보여주는 코드입니다
  1. Tv t;
  - Tv클래스 타입의 참조변수 t를 서언한다. 메모리에 참조변수 t를 위한 공간이 마련된다. 아직 인스턴스가 생성되지 않았으므로 참조변수로 아무것도 할 수 없다
  2. t = new Tv();
  - 연산자 new에 의해 Tv클래스의 인스턴스가 메모리의 빈 공간에 생성된다
  - 멤버변수는 각 자료형에 해당하는 기본값으로 초기화된다
  - color는 참조형이므로 null로, power는 boolean이므로 false로, channel은 int이므로 0으로 초기화된다
  - 대입연산자에 의해서 생성된 객체의 주소값이 참조변수 t에 저장된다
    - 참조변수 t를 통해 Tv인스턴스에 접근할 수 있다
      - 인스턴스를 다루기 위해서는 참조변수가 반드시 필요하다
  3. t.channel = 7;
  - 참조변수 t에 저장된 주소에 있는 인스턴스의 멤버변수 channel에 7을 저장한다
  - 인스턴스의 멤버변수(속성)을 사용하려면 '참조변수.멤버변수'와 같이 하면 된다
  4. t.channelDown();
  - 참조변수 t가 참조하고 있는 Tv인스턴스의 channelDown메서드를 호출한다
  - channel Down메서드는 멤버변수 channel에 저장되어 있는 값을 감소시킨다
  5. System.out.println("현재 채널은 " + t.channel + " 입니다.");
  - 참조변수 t가 참조하고 있는 Tv인스턴스의 멤버변수 channel에 저장되어 있는 값을 출력한다. 현재 channel의 값은 6이므로 '현재 채널은 6 입니다.'가 화면에 출력된다

```java
인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다
```

## 객체 배열

- 객체를 배열로 다루는 것이 가능하다
- 객체 배열 안에 객체가 저장되는 것으 ㄴ아니고, 객체즹 주소가 저장된다
  - 사실 객체 배열은 참조변수들을 하나로 묶은 참조변수 배열인 것이다

```java
Tv tv1, tv2,tv3;

Tv[] tvArr = new Tv[3];
```

- 객체 배열을 생성하는 것은, 그저 객체를 다루기 위한 참조변수들이 만들어진 것일 뿐, 아직 객체가 저장되지 않았다
  - 객체를 생성해서 객체 배열의 각 요소에 저장하는 것을 잊으면 안된다

```java
Tv[] tvArr = new Tv[3]; // 참조변수 배열 (객체 배열) 을 생성

// 객체를 생성해서 배열의 각 요소에 저장
tvArr[0] = new Tv();
tvArr[1] = new Tv();
tvArr[3] = new Tv();
```

- 배열의 초기화 블럭 사용

```java
Tv[] tvArr = { new Tv(), new Tv(), new Tv()};
```

- 다뤄야할 객체의 수가 많을 때는 for문을 사용

```java
Tv[] tvArr = new Tv[100];

for(int i=0;i<tvArr.length;i++) {
    tvArr[i] = new Tv();
        }
```

## 클래스의 정의

### 데이터와 함수의 결합

- 프로그래밍언어에서 데이터 처리를 위한 데이터 저장형태의 발전과정

```java
변수 -> 배열 -> 구조체 -> 클래스

1. 변수 : 하나의 데이터를 저장할 수 있는 공간
2. 배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체 : 서로 관련도니 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 : 데이터와 함수의 결합(구조체 + 함수)
```

- 서로 관련된 변수들을 정의하고 이들에 대한 작업을 수행하는 함수들을 함께 정의한 것이 바로 클래스이다
- 자바에서 문자열을 단순히 문자의 배열로 정의하지 않고 클래스로 정의한 이유는 문자열과 문자열을 다루는데 필요한 함수들을 함께 묶기 위해서이다

```java
public final class String implements java.io.Serializable, Comparable {
    private char[] value; // 문자열을 저장하기 위한 공간

    public String replace(char oldChar, char newChar) {
        ...
        char[] val = value; // 같은 클래스 내의 변수를 사용해서 작업을 한다
        ...
    }
}
```

### 사용자 정의 타입

- 프로그래밍언어에서 제공하는 기본 자료형(primitive type) 외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 '사용자 정의 타입(user=defined type)' 이라고 한다
- 객체지향언어에서는 클래스가 곧 사용자 정의 타입이다
  - 기본형의 개수는 8개로 정해져 있지만 참조형의 개수가 정해져 있지 않은 이유는 프로그래머가 새로운 타입을 추가할 수 있기 때문이다

```java
int hour; // 시간을 표현하기 위한 변수
int minute; // 분을 표현하기 위한 변수
float second; // 초를 표현하기 위한 변수 ,1/100초까지 표현하기 위해 float로 작성함
```

```java
int[] hour = new int[3];
int[] minute = new int[3];
float[] second = new float[3];
```

- 처리해야하는 시간 데이터의 개수가 늘어남녀 배열로 처리하면 된다
  - 변수를 매번 새로 선언해줘야하는 불편함과 복잡함은 사라졌지만, 시간을 구성하는 시, 분, 초가 서로 분리되어 있기 때문에 프로그램 수행과정에서 시,ㅣ 분, 초가 따로 뒤섞여서 올바르지 않은 데이터가 될 가능성이 있다
    - 시, 분, 초를 하나로 묶는 사용자정의 타입, 즉 클래스를 정의하여 사용해야 한다

```java
class Time {
    int hour;
    int minute;
    float second;
}
```

# 변수와 메서드

## 선언위치에 따른 변수의 종류

- 변수는 클래스 변수, 인스턴스 변수, 지역변수 모두 세 종류가 있다
- 변수의 종류를 결정짓는 중요한 요소는 '변수의 선언 위치'이므로 변수의 종류를 파악하기 위해서는 변수가 어느 영여겡 선언되었는 지를 확인하는 것이 중요하다
- 멤버변수를 제외한 나머지 변수들은 모두 지역 변수이며, 멤버변수 중 static이 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수이다

```java
class Variables{
    int iv; // 인스턴스 변수
    static int cv; // 클래스 변수(static변수, 공유변수

    void method(){
        int lv = 0; // 지역변수
    }
}
```

| 변수 종류                         | 선언 위치                | 범위                           | 생존 기간                                 | 예시                                            |
| --------------------------------- | ------------------------ | ------------------------------ | ----------------------------------------- | ----------------------------------------------- |
| 클래스 변수 (Static Variable)     | 클래스 내부, 메서드 외부 | 모든 객체(인스턴스) 공유       | 프로그램 실행부터 종료까지                | `static` 키워드로 선언된 클래스의 공유 변수     |
| 인스턴스 변수 (Instance Variable) | 클래스 내부, 메서드 외부 | 객체(인스턴스)별 별도 생성     | 객체(인스턴스) 생성부터 소멸까지          | 클래스의 멤버 변수로, 객체마다 고유한 값을 가짐 |
| 지역 변수 (Local Variable)        | 메서드 내부 블록 내부    | 해당 블록 내부에서만 접근 가능 | 블록 실행 시 생성되고 블록 종료 시 파괴됨 | 메서드 내에서 선언된 변수                       |

## 클래스 변수와 인스턴스 변수

```java
인스턴스 변수는 인스턴스가 생성될 때 마다 새성되므로 인스턴스마다 각기 다른 값을 유지할 수 있지만, 클래스 변수는 모든 인스턴스가 하나의 저장공간을 공유하므로, 항상 공통된 값을 갖는다
```

```java
class Card {

    String kind;
    int number;

    static int width = 100;
    static int height = 250;
}
```

## 메서드

- 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
- 기본적으로 수학의 함수와 유사하며, 어떤 값을 입력하면 이 값으로 작업을 수행해서 결과를 반환한다
- 내부가 보이지않는 '블랙박스(black box)'라고도 한다
- 메서드는 크게 두 부분, 선언부(header,머리)와 구현부(body, 몸통)으로 이루어져 있다
  - 메서드를 정의한다는 것은 선언부와 구현부를 작성하는 것을 뜻한다

## 메서드의 선언부

- 메서드 선언부는 '메서드의 이름'과 '매개변수 선언', 그리고 '반환타입'으로 구성되어 있으며, 메서드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는 지에 대한 정보를 제공한다

```java
int add (int x, int y) { // int(반환타입), add(메서드이름), int x, int y (매개변수선언)
    int result = x + y;

    return result; // 결과를 반환
        }
```

- 메서드의 선언부는 후에 변경사항이 발생하지 않도록 신중히 작성해야한다
  - 메서드의 선언부를 변경하게 되면, 그 메서드가 호출되는 모든 곳이 함께 변경되어야 하기 때문이다

### 매개변수 선언(parameter declaration)

- 매개변수는 메서드가 작업을 수행하는데 필요한 값들(입력)을 제공받기 위한 것이며, 필요한 값의 개수만큼 변수를 선언하며 각 변수 간의 구분ㅇ느 쉼표','를 사용한다
- 일반적인 변수선언과 달리 두 변수의 타입이 가아도 변수의 타입을 생략할 수 없다

```java
int add(int x, int y) {...} // OK
int add(int x, y) {...} // 에러, 매개변수 y의 타입이 없다
```

### 반환타입(return type)

- 메서드의 작업수행 결과(출력)인 '반환값(return value)'의 타입을 적는다
- 단, 반환값이 없는 경우 반환타입으로 'void'를 적어야한다

```java
void print99danAll() {
    for(int i=1;i<=9;i++) {
        for(int j=2;j<=9;j++) {
            System.out.print(j+"*"+i+"="+(j*i)+" ");
        }
        System.out.println();
        }
}
```

- 구구단 전체를 출력
  - 작업을 수행하는데 필요한 값(입력)도, 작업수행의 결과인 반환값(출력)도 없다
    - 그래서 반환타입이 void다

### 메서드의 구현부

- 메서드의 선언부 다음에 오는 괄호{}를 '메서드의 구현부'라고 한다
  - 메서드를 호출했을 때 수행도리 문장들을 넣는다

#### return문

- 메서드의 반환타입이 'void'가 아닌 경우, 구현부{} 안에 'return 반환값;'이 반드시 포함되어 있어야 한다
  - 이 문장은 작업을 수행한 결과이 반환값을 호출하 메서드로 전달하는데, 이 값의 타입은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다

```java
int add(int x, int y) {
    int result = x + y;
    return result; // 작업 결과(반환값)을 반환한다
        }
```

- 'return result;'는 변수 result에 저장된 값을 호출한 메서드로 반환한다
  - 변수 result의 타입이 int이므로 메서드 add의 바환타입이 일치하는 것을 알 수 있다
- 여러 개의 변수를 선언할 수 있는 매개변수와 달리 return문은 단 하나의 값만 반환할 수 있는데, 메서드로의 입력(매개변수)은 여러 개일 수 있어도 출력(반환값)은 최대 하나만 허용하는 것이다

#### 지역변수(local variable)

- 메서드 내에 선언된 변수를 '지역변수(local variable)'라고 한다
  - 메서드 내에 선언된 변수들은 그 메서드 내에서만 사용할 수 있으므로 서로 다른 메서드라면 같은 이름의 변수를 선언해도 된다

```java
int add(int x, int y) {
    int result = x + y;
    return result;
        }

int multiply(int x, int y) {
    int result = x * y;
    return result;
        }
```

- 메서드 add와 multiply에 각기 선언된 변수, x, y, result는 이름만 같을 뿐 서로 다른 변수이다

### 메서드의 호출

- 메서드를 정의했어도 호출되지 않으면 아무 일도 일어나지 않는다
  - 메서드를 호출해야만 구현부{}의 문장들이 수행된다

#### 인수(argument)와 매개변수(parameter)

- 메서드를 호출할 때 괄호() 안에 저장해준 값들을 '인수(argument)' 또는 '인자'라고 하는데, 인자의 개수와 순서는 호출된 메서드에 선언된 매개변수와 일치해야한다
- 인수는 메서드가 호출되면서 매개변수에 대입되므로, 인자의 타입은 매개변수의 타입과 일치하거나 자동 형벼화이 가능한 것이어야 한다

```java
int add(int x, int y) {
    int result = x + y;
    return result;
        }
```

```java
public static void main(String[] args) {
        ...
        int result = add(3, 5); // 메서드를 호출
        }
```

```java
int result = add(1, 2, 3); // 경고, 메서드에 선언된 매개변수의 개수가 다름
int result = add(1.0, 2.0); // 경고, 메서드에 선언된 매개변수의 타입이 다름
```

- 메서드에 선언된 매개변수의 개수보다 많은 값을 괄호()에 넣거나 타입이 다른 값을 넣으면 컴파일러가 경고를 발생시킨다

```java
int result = add(3,5); // int add(int x, int y)의 호출결과를 result에 저장
add(3,5); // OK. 메서드 add가 반환한 결과를 사용하지 않아도 된다
```

- 반환타입이 void가 아닌 경우, 메서드가 작업을 수행하고 반환한 값을 대입연산자로 변수에 저장하는 것이 보통이지만, 저장하지 않아도 문제가 되지않는다

### return문

- return문은 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다
- 반환값의 유무에 관계없이 모든 메서드에는 적어도 하나의 return문이 있어야한다
  - 반환타입이 void인 경우, return문 없이도 아무런 문제가 없었던 이유
    - 컴파일러가 메서드의 마지막에 'return;'을 자동적으로 추가해주었기 때문이다

```java
void printGugudan(int dan) {
    fpr(int i=1;i<=9;i++) {
        System.out.printf("%d * %d = %d%n", dan, i, dan * i)
        }
        return; // 반환 타입이 void이므로 생략가능. 컴퍼일러가 자동추가
}
```

- 반환타입이 void가 아닌 경우, 즉 바환값이 있는 경우, 반드시 return문이 있어야 한다
  - return문이 없으면 컴파일 에러(error: missing return statement)가 발생

```java
int multiply(int x, int y) {
    int result = x * y;

    return result; // 반환타입이 void가 아니므로 생략불가
        }
```

### 반환값

- return문의 반환값으로 주로 변수가 오긴 하지만 항상 그런 것은 아니다

```java
int add(int x, int y) {
    intresult = x + y;
    return result;
        }
```

==

```java
int add(int x, int y) {
    return x + y;
        }
```

- 수식이 반환되는 것은 아니고, 이 수식을 계산한 결과가 반환된다

```java
int diff(int x, int y) {
    return abs(x-y)
        }
```

- 메서드를 반환하는 것이 아니라 메서드 abs를 호출하고, 그 겨과를 받아서 반환한다
  - 메서드 abs의 반환타입이 메서드 diff의 반환티압과 일치하기 때문에 이렇게 하는 것이 가능함

```java
int abs(int x) {
    if(x>=0) {
        return x;
        }
    else {
        return -x;
        }
}
```

```java
int abs(int x) {
    return x>=0 ? x : -x;
        }
```

- 간단한 메서드의 경우 if문 대신 조건연산자를 사용하기도 한다
  - 메서드 abs는 입력받은 정수의 부호를 파단해서 음수일 경우 부호연산자(-)를 사용해서 양수로 반환한다

### 호출스택 (Call Stack)

- 호출스택은 메서드 호출을 추적하는 스택 자료구조입니다
- 메서드가 호출되면 해당 메서드 정보와 지역 변수가 스택에 저장되며, 메서드가 실행을 완료하면 정보가 스택에서 제거됩니다
  - 이를 통해 호출 순서를 추적하고 메서드 호출을 관리합니다.

예시:

```java
public void methodA() {
    int x = 5;
    methodB();
}

public void methodB() {
    String message = "Hello";
    // ...
}
```

- 메서드 `methodA`가 호출되면 호출스택에 `methodA`의 정보가 추가되고, 그 안에서 `methodB`가 호출되면 `methodB`의 정보가 추가됩니다

### 기본형 매개변수 (Primitive Type Parameters)

```java
기본형 매개변수 : 변수의 값을 읽기만 할 수 있다(read only)
```

예시:

```java
public void modifyValue(int num) {
        num = num * 2;
        }
```

### 참조형 매개변수 (Reference Type Parameters)

```java
참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다(read & write)
```

예시:

```java
public void modifyArray(int[] arr) {
    arr[0] = 100;
}
```

### 참조형 반환타입 (Reference Type Return)

- 참조형 반환타입은 메서드가 객체를 반환할 때 사용됩니다
- 반환값은 객체의 참조이므로, 호출자는 반환된 객체를 통해 내용을 변경할 수 있습니다

예시:

```java
public ArrayList<String> createList() {
    ArrayList<String> list = new ArrayList<>();
    list.add("Apple");
    list.add("Banana");
    return list;
}
```

### static 메서드와 인스턴스 메서드 (Static Methods vs. Instance Methods)

- `static 메서드`는 클래스 레벨에서 호출할 수 있고, 객체 생성 없이 사용할 수 있습니다
- `인스턴스 메서드`는 객체에 속하며, 객체를 생성한 후에만 호출할 수 있습니다

예시:

```java
public class MathUtil {
    public static int add(int a, int b) {
        return a + b;
    }

    public int multiply(int a, int b) {
        return a * b;
    }
}
```

### static을 언제 붙여야 할까?

- 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다
  - 생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수는 서로 다른 값을 유지한다
- 클래스 변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다
  - static이 붙은 변수(클래스 변수)는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다
- 클래스 메서드(static메서드)는 인스턴스를 생성하지 않아도 사용할 수 있다
  - 인스턴스 변수는 인스턴스가 반드시 존재해야만 사용할 수 있는데, 클래스메서드(static이 붙은 메서드)는 인스턴스 생성없이 호출가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지않을 수도 있다
- 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다
  - 메서드의 작업내용 중에서 인스턴스변수를 필요로 한다면, static을 붙일 수 없다. 반대로 인스턴스변수를 필요로 하지 안ㅇㅎ는다면 static을 붙이자. 메서드 호출시간이 ㅉ랍아지므로 성능이 향상된다

### 메서드 간의 호출과 참조

- 같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다
  - 단, 클래스멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 겨웅에는 인스턴스를 생성해야 한다 \* 그 이유는 , **인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있기 때문이다**
    예시:

```java
public void printSum() {
    int a = 5;
    int b = 3;
    int sum = calculateSum(a, b);
    System.out.println("Sum: " + sum);
}

public int calculateSum(int x, int y) {
    return x + y;
}
```

`printSum` 메서드에서 `calculateSum` 메서드를 호출하고, 계산 결과를 출력합니다.
